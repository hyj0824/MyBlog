---
tags:
  - 数学
  - 二进制
date: 2023-06-29
dg-publish: true
dg-permalink: 线性基
---


## 简述

**矩阵的秩（向量线性基）**：在线性代数中，一个矩阵A的列秩是A的线性独立的纵列的极大数目。类似地，行秩是A的线性无关的横行的极大数目。

方阵的列秩和行秩总是相等的，因此它们可以简单地称作矩阵的秩。通常表示为$r(A),rk(A),rank(A)$

m × n矩阵的秩最大为m和n中的较小者，表示为 min(m,n)。

**线性相关**：能被多个向量基表示

**异或空间线性基**与线性空间类似，求 $n$ 个数的线性基，可以看成求 $n$ 个向量的基，二进制位数类似于维数。

## 用处

- 快速查询一个数是否可以被一堆数异或出来
- 快速查询一堆数可以异或出来的最大/最小值
- 快速查询一堆数可以异或出来的第k大值

## 求法

### 高斯消元求线性基

```cpp
#include <bits/stdc++.h>
using ull = unsigned long long;
const int MAXN = 1e5 + 5;

ull deg(ull num, int deg) { return num & (1ull << deg); }

ull a[MAXN];

int main() {
  int n;
  scanf("%d", &n);
  for (int i = 1; i <= n; ++i) scanf("%llu", &a[i]);
  int row = 1;
  for (int col = 63; ~col && row <= n; --col) {
    for (int i = row; i <= n; ++i) {
      if (deg(a[i], col)) {
        std::swap(a[row], a[i]);
        break;
      }
    }
    if (!deg(a[row], col)) continue;
    for (int i = 1; i <= n; ++i) {
      if (i == row) continue;
      if (deg(a[i], col)) {
        a[i] ^= a[row];
      }
    }
    ++row;
  }
  ull ans = 0;
  for (int i = 1; i < row; ++i) {
    ans ^= a[i];
  }
  printf("%llu\n", ans);
  return 0;
}
```

### 贪心法求线性基


## 增删改查

### 验证线性相关
### 异或最值
### 第k大值

求出可异或的最大值，若是一串连续且没有后缀的1，那第k大其实就是k。

现在相当于告诉你在这一串1中夹了很多0，问你第k大是多少。那么你其实可以不用管中间的0，把k的二进制形式弄出来，然后把中间省略0给插回去就好了。  
解释一下就相当于把线性基异或后出来的最大值里的所有1都给挤到最后，然后求出第k大，再把你弄走的0给丢回去。

eg:异或后最大值为101100110，问第20大

挤到后面去后成11111，第k大是10100，把0插回去成为100100000，第20大便是100100000

显然的证明：随便弄出两个数，把他们转成2进制，然后去掉公共的0，发现两个数的相对大小关系不变。两个数的大小比较相当于在他们位数相同（或添上前导0后位数相同）的情况下比他们的字典序，而除去公共0后字典序的相对关系是不变的。

嗯就是这样，记得特判可不可以异或出0。


https://www.luogu.com.cn/problem/P4151